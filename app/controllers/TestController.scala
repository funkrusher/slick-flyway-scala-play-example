package controllers

import dto.models.{AuthorModel, BooksWithAuthorsModel}
import dto.{AuthorRepository, BookRepository}
import javax.inject.{Inject, Singleton}
import play.api.db.slick.DatabaseConfigProvider
import play.api.i18n.I18nSupport
import play.api.libs.json.Json
import play.api.mvc.{AbstractController, Action, AnyContent, ControllerComponents}
import slick.jdbc.JdbcProfile

import scala.concurrent.ExecutionContext.Implicits.global

@Singleton
class TestController @Inject()(
                                dbConfigProvider: DatabaseConfigProvider,
                                cc: ControllerComponents,
                                authorRepository: AuthorRepository,
                                bookRepository: BookRepository) extends AbstractController(cc) with I18nSupport {
    // We want the JdbcProfile for this provider
    val dbConfig = dbConfigProvider.get[JdbcProfile]

    // These imports are important, the first one brings db into scope, which will let you do the actual db operations.
    // The second one brings the Slick DSL into scope, which lets you define the table and other queries.

    import dbConfig._
    import profile.api._


    /**
     * Tests transactional error with rollback
     *
     * @return success-status
     */
    def test5: Action[AnyContent] = Action.async { implicit request =>

        // see also: https://github.com/slick/slick/issues/1197
        // see also: https://stackoverflow.com/questions/38221021/transactional-method-in-scala-play-with-slick
        // -similar-to-spring-transactional

        val action = (for {
            // those statements are potentially in parallel with two parallel running connections,
            // but because the second depends on the first, the second is waiting until the first is finished.
            author <- authorRepository.fetchByIdAction(1)
            author2 <- authorRepository.fetchByIdAction(2)
            save1 <- authorRepository.saveAction(author.head.copy(id = 1000, first_name = Some("Gustave")))
            save2 <- authorRepository.saveAction(author.head.copy(id = 1001, first_name = Some("Lydia")))

        } yield (author, author2, save1, save2)).flatMap {
            case (author, author2, save1, save2) =>
                // lets force a rollback after all statements have been resolved
                // but while the transactionlly is still open.
                DBIO.failed(new Exception("force a rollback of the transaction with this ex-throw!"))
        }.transactionally;


        db.run(action).map({
            case (r) =>
                // render html-view
                Ok("OK")
        })
    }


    /**
     * Tests multi-joined fetch
     *
     * @return success-status
     */
    def test6: Action[AnyContent] = Action.async { implicit request =>

        val result = for {
            // those statements are potentially in parallel with two parallel running connections,
            // but because the second depends on the first, the second is waiting until the first is finished.
            books <- bookRepository.fetchAllByBookStoreNames(Seq("Orell FÃ¼ssli"))
            authors <- authorRepository.fetchAllByBookIds(books.map(x => x.id))
        } yield (books, authors)

        result.map({
            case (books, authors) =>
                // the books and authors are of the jOOQ-Record type.
                // we can not serialize them easily as json.
                // just to test it out we push the jOOQ-Record into Scala Case-Classes which can be serialized
                // but it would be a bad idea to reintroduce handwritten classes in addition to the autogenerated ones.
                // TODO maybe consider using Jackson-Serizalizer Library instead of the OFormat

                val booksWithAuthors: Seq[BooksWithAuthorsModel] = books.map({
                    book =>
                        val foundAuthors = authors
                          .filter(author => author.id.equals(book.author_id))
                          .map(author => new AuthorModel(
                              author.id, author.first_name, author.last_name, author.date_of_birth,
                              author.year_of_birth, author.distinguished));
                        new BooksWithAuthorsModel(
                            id = book.id,
                            authors = foundAuthors);
                })
                Ok(Json.obj(
                    "booksWithAuthors" -> booksWithAuthors
                ))
        })
    }
}